I"N<p>TODO: intro/requirements/goals</p>

<p>Basis:</p>
<figure class="captioned_image fill_white">
	<a class="open_img" href="/assets/images/Procedural Tectonic Planets.gif" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/Procedural Tectonic Planets.gif" alt="" />
	</a>
  <figcaption><a href="https://hal.archives-ouvertes.fr/hal-02136820/file/2019-Procedural-Tectonic-Planets.pdf">Procedural Tectonic Planets by Cortial et al.</a> is a paper from 2019 that TODO TODO TODO</figcaption>
</figure>

<!--more-->

<h1 id="model">Model</h1>

<p>TODO: delaunay triangulation; vertices = sub-plates; each vertex with its own elevation, type and velocity, but belonging to a meta-plate, identified by an id; through triangulation each vertex is connected to its closest neighbors</p>
<ul>
  <li>Triangle appoximation = main difference to paper / has been underspecified in paper)</li>
</ul>

<p>TODO: Steps:</p>
<ul>
  <li>Generate initial plate arrangement</li>
  <li>Simulate plates in a loop: move based on velocity + modify velocity based on neighbors</li>
</ul>

<h1 id="initial-state">Initial State</h1>

<p>TODO: <code>generate_sphere</code> + <code>generate_plates</code></p>
<ul>
  <li>Fibonacci sphere + small random offsets (1/2 step-size to avoid collisions) =&gt; even distribution, without obvious poles, no obvious patterns in vertices or triangulation</li>
  <li>QuickHull (might later be replaced, but currently fast enough) =&gt; delaunay triangulation</li>
  <li>Pick N random starting points (retry if position is already taken)
    <ul>
      <li>Type: First M are ocean, rest are continental plates</li>
      <li>Id: incrementing counter starting from 1 (0=no plate)</li>
      <li>Velocity: Random Angle and Speed =&gt; Generate 3D-Vector, tangential to surface normal (normalized position of vertex)</li>
      <li>Elevation/Creation-Time: Random in given range based on type</li>
    </ul>
  </li>
  <li>Flood Fill
    <ol>
      <li>For each vertex that we just assigned to a plate: Add neighbors to the same plate
        <ul>
          <li>Id/Type are copied</li>
          <li>Velocity is modified to be tangential to surface normal
```cpp</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p>auto p           = (*positions)[n];
auto np          = normalized(p + velocity * 100.f) * length(p);
velocities[n]    = (np - p) / 100.f;
```
        - Increase/decrease creation time slightly based on type: <code>type == pt_oceanic ? created_time * 0.9f : created_time * 1.1f;</code>
        - Copy elevation, but disturb it slightly for continental plates
    2. Randomly shuffle the list of vertices that were modified in this iteration and goto step 1, until no vertices have been modified</p>

<figure class="captioned_image ">
	<div class="open_img">
	<video loop="" muted="" inline="" controls="">
		<source src="/assets/images/sphere_plates.webm" type="video/webm" />
	</video>
	</div>
  <figcaption>TODO</figcaption>
</figure>

<figure class="captioned_image ">
	<div class="open_img">
	<video loop="" muted="" inline="" controls="">
		<source src="/assets/images/sphere_plate_directions.webm" type="video/webm" />
	</video>
	</div>
  <figcaption>TODO</figcaption>
</figure>

<h1 id="simulation">Simulation</h1>

<p>TODO: general idea</p>

<p>Steps:</p>
<ol>
  <li>Refinement</li>
  <li>identify type of boundaries between sub-plates =&gt; remember in edge-layer</li>
  <li>spawn new plates on ridge-boundaries</li>
  <li>Calculate forces acting on plates</li>
  <li>Simulate plate movement: Update plate velocity and move them (re-normalize to plate surface)</li>
  <li>Update elevation at subduction and collision boundaries</li>
  <li>Check if there accoured collisions between plates during movement and resolve them</li>
  <li>Restore Delaunay condition</li>
  <li>Fix triangles that are extremly thin or have an extremly small height (=&gt; vertices are nearly colliding)</li>
  <li>Restore Delaunay condition (again)</li>
  <li>Apply simple erosion</li>
  <li>Split/Combine meta-plates</li>
</ol>

<h2 id="1-refinement">1. Refinement</h2>
<p>TODO</p>

<h2 id="2-identify-boundary-types">2. Identify boundary-types</h2>
<p>TODO</p>

<h2 id="3-spawn-new-plates">3. Spawn new plates</h2>
<p>TODO</p>

<h2 id="4-calculate-forces">4. Calculate forces</h2>
<p>TODO</p>

<h2 id="5-simulate-plate-movement">5. Simulate plate movement</h2>
<p>TODO</p>

<h2 id="6-update-elevation">6. Update elevation</h2>
<p>TODO</p>

<h2 id="7-solve-collisions">7. Solve Collisions</h2>
<p>TODO</p>

<h2 id="8-and-10-restore-delaunay-condition">8. and 10. Restore Delaunay condition</h2>
<p>TODO</p>

<h2 id="9-fix-degenerated-triangles">9. Fix degenerated triangles</h2>
<p>TODO</p>

<h2 id="11-simulate-erosion">11. Simulate Erosion</h2>
<p>TODO</p>

<h2 id="12-splitcombine-plates">12. Split/combine plates</h2>
<p>TODO</p>

<h1 id="conclusion">Conclusion</h1>
<p>TODO: results</p>

<p>TODO: future developments</p>
<ul>
  <li>Detail generation (based on paper)</li>
  <li>Hot-Spots (e.g. Hawaii)</li>
  <li>Climate and hydrology simulation =&gt; rivers + better erosion</li>
</ul>

:ET