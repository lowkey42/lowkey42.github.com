I"•§<p>This will (hopefully) be the last post about geometry and the Mesh-API, before we can start with the actual generation algorithms.</p>

<p>Weâ€™ve already defined a basic data structure for our geometry, implemented algorithms to traverse it and, in the last post, constructed a spherical delaunay triangulation of random points, distributed evenly on a sphere.</p>

<p>So the only part of the API that is still missing are functions to modify existing meshes. The three fundamental operations weâ€™ll define for this are the following:</p>

<pre><code class="language-cpp">class Mesh {
  public:
	// ...
	
	void   flip    (Edge e);
	Edge   split   (Edge e, float split_point);
	Vertex collapse(Edge e, float join_point);
};
</code></pre>

<!--more-->

<h2 id="edge-flip">Edge Flip</h2>

<p>The first of the three operations is the edge flip, that weâ€™ll need later to restore the delaunay condition of our mesh after vertices have been moved<sup class="footnote" onclick="showFootnote(this)" title="we will look at that in more detail later, but the basic algorithm we'll be using is: Calculate the circumcircle of each face, check if there is another vertex (of a neighboring faces) that lies inside this circle and if there is one flip the edge we share with its face.">[1]</sup>.</p>

<p>The effect of an edge flip is relatively straightforward. It just takes the edge, that is passed to it, and rotates it counterclockwise in the quad formed by the four surrounding vertices, as seen below:</p>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/04/flip/initial.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/04/flip/initial.png" alt="" />
	</a>
  <figcaption>Initial mesh before flip</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/04/flip/final.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/04/flip/final.png" alt="" />
	</a>
  <figcaption>Mesh after the <code class="highlighter-rouge">flip(e)</code></figcaption>
</figure>

</div>

<p>What we have ultimately done here is we removed the passed edge, to transform the two neighboring faces into a quad and then created a new edge between the previously unconnected vertices to split it into two triangles again. From this we also see, that we canâ€™t flip edges at the boundary of our mesh, that only have a single face.</p>

<p>Our implementation is further simplified by the fact that we donâ€™t need to handle multiple cases, like we had for <code>add_face()</code>. The reason is that there are only two possible ways to split a quad, which means the result is always unambiguous, regardless of which part of a quad-edge we pass as the argument. That means <code>flip(e)</code>, <code>flip(e.rot())</code>, <code>flip(e.sym())</code> and <code>flip(e.inv_rot())</code> are all equivalent and we can just normalize the input and ignore all other cases, like flipping dual edges.</p>
<pre><code class="language-cpp">e = e.base();
</code></pre>

<p>As always there are two parts to this operation: Updating the primal mesh and its dual counterpart:</p>

<h3 id="primal-mesh">Primal Mesh</h3>

<p>The update of the primal mesh is pretty straight forward. We just need to remove <code>e</code> and <code>e.sym()</code> from their old and add them to their new edge-rings<sup class="footnote" onclick="showFootnote(this)" title="How exactly we determine the next/previous edges in the new edge-rings might not be obvious at first. But it should be visualizable by manually applying the traversal operations we've seen in the last post, to step through the topology by hand.">[2]</sup>:</p>
<pre><code class="language-cpp">// Remove e and e.sym() from their current edge-rings
new_origin_next[e.origin_prev(mesh)]       = e.origin_next(mesh);
new_origin_next[e.sym().origin_prev(mesh)] = e.sym().origin_next(mesh);

// Add e to its new edge-ring
new_origin_next[e.dest_next(mesh)] = e;
new_origin_next[e]                 = e.origin_prev(mesh).sym();

// Add e.sym() to its new edge-ring
new_origin_next[e.origin_next(mesh).sym()] = e.sym();
new_origin_next[e.sym()]                   = e.dest_prev(mesh);

// ...

// Check if the original origin/dest vertices referenced the flipped edge
//   and set them to one of the remaining edges, if required
if(vertex_edges_[e.origin(mesh)] == e)
	vertex_edges_[e.origin(mesh)] = e.origin_next(mesh);
if(vertex_edges_[e.dest(mesh)] == e.sym())
	vertex_edges_[e.dest(mesh)] = e.sym().origin_next(mesh);

// Update the origin
primal_edge_origin_[e.index()] = e.origin_prev(mesh).dest(mesh);
primal_edge_origin_[e.sym().index()] = e.origin_next(mesh).dest(mesh);

// Apply the changes
new_origin_next.apply(primal_edge_next_);
</code></pre>

<p>Because we need to traverse the mesh during our modification, we need to be careful that we only override the data <em>after</em> weâ€™ve read all required information. Therefor we need to load and cache all values before we can write the new values to the <code>Mesh</code> member variables. So to make our lives easier and the code more readable, we use <code>new_origin_next</code> to memorize the new values and only apply them at the end using a class like this:</p>
<pre><code class="language-cpp">template &lt;typename Value, std::size_t N&gt;
class Edge_changes {
  public:
	// Array-Access-Operator reserves space for the new value
	//   and returns a reference to it
	Value&amp; operator[](Edge e) {
		assert(next_idx_ &lt; int(new_values_.size()));
		auto&amp; e = new_values_[next_idx_++];
		e.first = e.index();
		return e.second;
	}

	// Apply the recorded changes to the given vector
	void apply(std::vector&lt;Value&gt;&amp; out) {
		for(int i = 0; i &lt; next_idx_; i++) {
			auto&amp;&amp; [index, val] = new_values_[i];
			out[index]          = val;
		}
	}

  private:
	std::array&lt;std::pair&lt;uint32_t, Value&gt;, N&gt; new_values_;
	int                                       next_idx_ = 0;
};

// Later instanciated with
auto new_origin_next = Edge_changes&lt;Edge, 6&gt;{};
</code></pre>

<h3 id="dual-mesh">Dual Mesh</h3>

<p>Updating the dual mesh might look more complex at first, because the flip also changes which faces are neighboring each other, but itâ€™s actually simpler, because the edge-rings around faces are much more restricted. Since every face has exactly three outgoing edges and all flips are identical, we can just look at our diagram and see that we only need to swap two dual edges from the rings around <code>e.left()</code> and <code>e.right()</code>.</p>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/04/flip/initial_dual.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/04/flip/initial_dual.png" alt="" />
	</a>
  <figcaption>Initial mesh before flip, with the two edges of the dual mesh that need to be moved highlighted.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/04/flip/final_dual.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/04/flip/final_dual.png" alt="" />
	</a>
  <figcaption>Mesh after the <code class="highlighter-rouge">flip(e)</code>. The dual edge <code class="highlighter-rouge">de1</code> has been moved to the left and <code class="highlighter-rouge">de2</code> to the right face, after <code class="highlighter-rouge">e.rot()</code> and <code class="highlighter-rouge">e.inv_rot()</code> respectively.</figcaption>
</figure>

</div>

<pre><code class="language-cpp">// Move edge from left face to right face
const auto edge_from_left      = e.inv_rot().origin_next(mesh);
const auto edge_from_left_prev = e.rot().origin_prev(mesh);
new_dual_origin_next[edge_from_left]      = e.rot();
new_dual_origin_next[e.rot()]             = edge_from_left_prev;
new_dual_origin_next[edge_from_left_prev] = edge_from_left;

// Move edge from right face to left face
const auto edge_from_right      = e.rot().origin_next(mesh);
const auto edge_from_right_prev = e.inv_rot().origin_prev(mesh);
new_dual_origin_next[edge_from_right]      = e.inv_rot();
new_dual_origin_next[e.inv_rot())          = edge_from_right_prev;
new_dual_origin_next[edge_from_right_prev) = edge_from_right;

// ... Update the primal mesh, as seen above ...

// Set the edges for the modified faces to one of the edges
face_edges_[e.left(mesh)] = e;
face_edges_[e.right(mesh)] = e.sym();

// Update the origin
dual_edge_origin_[edge_from_left.index()]  = e.right(mesh);
dual_edge_origin_[edge_from_right.index()] = e.left(mesh);

// Apply the changes
new_dual_origin_next.apply(primal_edge_next_);
</code></pre>

<h2 id="edge-split-and-collapse">Edge Split and Collapse</h2>

<p>One of the key advantages of representing our map as a triangle mesh, is that we can dynamically add/remove vertices to change the local resolution of our data. That means that we can use far less vertices in the middle of the ocean, where we donâ€™t care about most terrain features, and use the such saved storage for the parts that actually interest us, like mountains, coastlines and river-systems.</p>

<p>To achieve this we need two operations, one to add a new vertex at a given point and one to remove vertices:</p>
<ul>
  <li><code>Edge split(Edge e, float split_point)</code>: Takes an edge and a position on this edge <sup class="footnote" onclick="showFootnote(this)" title="represented as a floating point number to interpolate between the origin (0.0) and destination (1.0) vertex ">[3]</sup> and splits the edge into two edges, creating a new vertex at the given position and inserting edges and faces left/right of the edge, as required. The returned value is the new half of the split edge, from the new vertex to the original destination. <sup class="footnote" onclick="showFootnote(this)" title="The more common variant of this operation is a vertex-split, that functions similarly but splits a vertex into two vertices, inserting an edge between them, instead of splitting an edge. But that would make it more complex to define the position where the split should occur, which is important for us because our vertices store far more information than just their positions. ">[4]</sup></li>
  <li><code>Vertex collapse(Edge e, float join_point)</code>: Takes an edge and a position on it and collapses the edge, merging the <code>origin()</code> and <code>dest()</code>, as well as its <code>left()</code> and <code>right()</code> faces.</li>
</ul>

<p>Note: While, in theory, these two function could be implemented to work with both primal and dual edges, weâ€™ll make our life much easier by forbidding dual edges and work exclusively on the primal mesh in this case.</p>

<p>As can be seen in the following image, we can interpret the operations as each otherâ€™s inverse.</p>

<figure class="captioned_image" style="max-width: 40em; width: calc(100% - 2em)">
	<a class="open_img" href="/assets/images/04/split_collapse/overview.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)" style="width: calc(100% - 2em)">
		<img style="float:none" src="/assets/images/04/split_collapse/overview.png" alt="example of splitting and collapsing an edge" />
	</a>
<figcaption>

    <p>Executing <code class="highlighter-rouge">split(e, 0.25f)</code> transforms the left mesh into the right one, inserting a new vertex â€“ 25% along the way between the origin and destination of e â€“, two faces â€“ F<sub>L</sub> and F<sub>R</sub> â€“ and three quad-edges.</p>

    <p>Executing <code class="highlighter-rouge">collapse(e', 1.f)</code> reverses this operation. The edge eâ€™ is removed and its origin and destination, as well as its left and right face, are collapsed into a single vertex, that keeps the position of the destination (100% along the way from origin to destination).</p>

  </figcaption>
</figure>

<p>While the implementation is a bit more intricate, because we have more edges to consider, it follows the same procedure as <code>flip()</code>, i.e. connect the edges into valid edge-rings. So I wonâ€™t go into too much detail here and focus on the preconditions and how deletions are handled, instead.</p>

<h3 id="preconditions">Preconditions</h3>

<p>The precondition of <code>split()</code> is quite simple â€“ simpler than that of <code>flip()</code> even â€“ because it works on any edge with at least one face, which includes boundary edges. That is also the one special case we need to handle in the implementation: Are both faces present or are we splitting a boundary edge and the left/right face is missing.</p>

<p>The situation for <code>collapse()</code> is quite different, however. Although, it also could function with any valid edge with at least one face, collapsing some edges might create invalid meshes. What all of these have in common, is that <code>collapse()</code> would have to collapse more than the left/right faces or else leave unconnected edges or vertices behind. So there are two conditions we need to check first to avoid these corruptions.</p>

<h4 id="1-the-link-condition">1. The Link Condition</h4>

<p>The first thing we need to check is that the edge we want to collapse satisfies the link condition, defined in the paper â€˜â€˜Topology Preserving Edge Contractionâ€™â€™, that guarantees that our manifold mesh will still be manifold after the <code>collapse()</code>.</p>

<p>Its formal definition is, given the edge <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> between vertices <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>:</p>

<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>one-ring</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>âˆ©</mo><mtext>one-ring</mtext><mo stretchy="false">(</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mtext>one-ring</mtext><mo stretchy="false">(</mo><mi>e</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{one-ring}(v_1) \cap \text{one-ring}(v_2) = \text{one-ring}(e)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">one-ring</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ©</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">one-ring</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">one-ring</span></span><span class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span>

<p>Put simply, this means that every vertex that is connected to both <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> also has to be part of the face on the left or right side of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span>. When put like this we also see the problem, that would arise if we ignored this condition: After we collapsed <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">e</span></span></span></span> there would be multiple different edges between <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">v_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">v_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>

<figure class="captioned_image" style="max-width: 40em; width: calc(100% - 2em)">
	<a class="open_img" href="/assets/images/04/link_condition_pre.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)" style="margin-left: auto; margin-right: auto">
		<img style="float:none" src="/assets/images/04/link_condition_pre.png" alt="example of an edge that doesn't satisfy the link condition" />
	</a>
<figcaption>

    <p>An example of an edge that doesnâ€™t satisfy the link condition. The origin and destination of e are both connected to the vertex V<sub>P</sub>, which means the intersection of their one-rings contains the vertex V<sub>P</sub>, that is missing in the one-ring of e.<br />This means that we would have to also collapse some of the edges and faces around V<sub>P</sub> or produce a non-manifold mesh. Which is why this case is forbidden.</p>

  </figcaption>
</figure>

<p>To check this condition we can just iterate over the edge-ring around <code>e.origin()</code> and check if one of its neighboring vertices is also a neighbor of <code>e.sym()</code>. For this we can utilize the <code>Edge::origin_ccw()</code> method, that returns a range of all edge in the origin-edge-ring, and the <code>std::find_first_of</code> algorithm, that tries to find the first matching element between two ranges. Of course, when iterating over the edge-rings we have to skip the first element, which is <code>e</code> itself. But we also need to skip the edge after that, if there is a face on that side of <code>e</code>, because these edges are still part of the left/right face.</p>

<p><br style="clear:both" /></p>

<pre><code class="language-cpp">// Iterator ranges over the two edge-rings, starting from the edge after e (the edge we are collapsing)
// We also need to skip the vertex of the neighboring face, if there is one
const auto origin_edges = e.origin_ccw(mesh).skip(left ? 2 : 1);
const auto dest_edges   = e.sym().origin_ccw(mesh).skip(right ? 2 : 1);

// Check if there is an edge in the two ranges that share a common destination vertex
const auto iter = std::find_first_of(origin_edges.begin(),
                                     origin_edges.end_iterator(),
                                     dest_edges.begin(),
                                     dest_edges.end_iterator(),
                                     [&amp;](Edge oe, Edge de) { return oe.dest(mesh) == de.dest(mesh); });

if(iter != origin_edges.end()) {
	// If there is such an edge the link condition is not satisfied
	yggdrasill::make_error(out_error, YGDL_ERROR_CODE_MESH_CORRUPTION, [&amp;] {
		return "The link-condition is not satisfied for the edge passed to collapse()";
	});
	return no_vertex;
}
</code></pre>

<h4 id="2-vertices-shared-by-unconnected-faces">2. Vertices Shared by Unconnected Faces</h4>

<p>While we can find most problematic cases by checking the link condition, there are still some we need to check separately, that are caused by our less restrictive mesh definition (e.g. unconnected sub-meshes, faces connected by only one vertex, unclosed meshes, â€¦).</p>

<p>One of these is the â€˜â€˜forbidden caseâ€™â€™ we excluded in <code>add_face()</code>, but now coming from the opposite direction. That is, we canâ€™t collapse an edge if that would result in a vertex that is shared by multiple unconnected faces.</p>

<p>And the other class of cases are those that would leave behind vertices without edges.</p>

<p>We can identify both of these by checking if there are multiple boundary edges originating from <code>e.origin()</code> or <code>e.dest()</code> that are missing a face on the same side.</p>

<pre><code class="language-cpp">if(e.left(mesh) != no_face &amp;&amp; e.right(mesh) != no_face) {
	// We only need to check this, if e is not already a boundary edge

	// We want to check if there are any edges in the given range, that don't have a right face
	auto has_right_boundary = [&amp;](const auto&amp; edge_range) {
		return std::any_of(edge_range.begin(), edge_range.end_iterator(),
		                   [&amp;](Edge e) {return e.right(mesh) == no_face;} );
	};
	
	// ... and we want to check if that is the case around both the origin and destination of e 
	if(has_right_boundary(e.origin_ccw(mesh)) &amp;&amp; has_right_boundary(e.sym().origin_ccw(mesh))) {
		yggdrasill::make_error(out_error, YGDL_ERROR_CODE_MESH_CORRUPTION, [&amp;] {
			return "Requested edge collapse would cause a corrupted mesh (multiple unconnected faces "
			       "on the same vertex) or a dangling vertex";
		});
		return no_vertex;
	}

} else if(e.left(mesh) == no_face &amp;&amp; e.right(mesh) == no_face) {
	// The edge e is not part of any faces, which means the initial mesh is not valid to begin with
	yggdrasill::make_error(out_error, YGDL_ERROR_CODE_MESH_CORRUPTION, [&amp;] {
		return "Corrupted mesh. The edge that should be collapsed is not part of a triangle";
	});
	return no_vertex;
}
</code></pre>

<h3 id="handling-deletions">Handling Deletions</h3>

<p>Although, we now know how our data structure needs to change on <code>split()</code> and <code>collapse()</code>, there is one point we glossed over, which we briefly touched on when we first defined our mesh structure: Deleting elements of our mesh (vertices, faces and edges)</p>

<p>As we have seen above, collapsing an edge effectively deletes it, as well as its destination, bordering faces and some of their edges. But that is a problem, because we canâ€™t just directly delete part of our <code>Mesh</code> structure since we store all data of our elements in continuous vectors. So if we would just delete e.g. an edge from this structure we would need to move all following values to close the gap and keep everything contiguous. However, that would not just be extremely inefficient for larger meshes, but also disturb our IDs. Remember that the ID of an element is also the index in the corresponding data-vector<sup class="footnote" onclick="showFootnote(this)" title="Or at least derived from it, in case of edges.">[5]</sup>. So if the index would change, that in turn would also change its ID, which we use <em>everywhere</em> to reference it. Which means we canâ€™t do that and need a different solution.</p>

<p>Luckily we already reserved one special ID for each of the element types, to represent a missing or invalid element (<code>no_edge</code>/<code>no_vertex</code>/<code>no_face</code>), which we can utilize now. Instead of deleting an element, we will instead memorize its ID in a vector (called a free-list) and set all its values in the <code>Mesh</code> to this invalid state. And then when we later need to create new vertices, edges or faces, we can check this free-list first before allocating new storage, to fill in these â€˜â€˜holesâ€™â€™ the deletions left behind.</p>

<p>Of course, if we never really delete elements but just mark them as deleted, we must take care that they are never referenced or returned from any of our function. Following the algorithm outlined above, there already should never be any part of the mesh that references the vertices/edges/faces that were deleted, since these references were overridden by new values. So the traversal operations should already work as expected, without any further work from our part. But where we need to do extra work is when we iterate over <em>all</em> vertices/faces/edges in the mesh. These operations would normally just iterate over all indices and return the corresponding IDs. So we need to add an extra check in the iterator, that reads one of the elements values from <code>Mesh</code> and checks whether it is set to a valid value.</p>

<p>Although, this means extra work on a relatively common operation, a linear read and comparison of 32-Bit integers should not impact us much. So, at least for the expected use-case were meshes donâ€™t shrink over time, so that only relatively few elements are marked as deleted at any time, this should be pretty efficient.</p>

<h2 id="handling-topological-changes-in-data-layers">Handling Topological Changes in Data Layers</h2>

<p>Before we can (finally) close this chapter, there is one last aspect that deserves attention: How the data layers react to changes</p>

<p>As already mentioned weâ€™ll store all our data in layer that<sup class="footnote" onclick="showFootnote(this)" title="with the exception of unstructured layers ">[6]</sup> bind values of various types to parts of our mesh (vertices, faces and directed or undirected edges of the primal/dual mesh). So when we modify the mesh itself that will obviously affect the layer values for elements we added or deleted. But it might also invalidate information that was used to compute the values, e.g. if we <code>flip()</code> an edge no parts of the mesh are deleted, but some edges will be connected to completely different vertices.</p>

<p>Hence, weâ€™ll need a way to automatically modify layers if the mesh is changed, which is actually one of the reasons why weâ€™ve defined the overarching <code>World</code> structure that contains both the mesh and all layers. So when one of the modification operations of the mesh is called, we can just access the layers through our parent <code>World</code>, lock them for modification and apply any necessary changes to them.</p>

<p>Of course, that begs the question of <em>what</em> changes would be necessary. When we modify the mesh we already know which parts of the mesh will be affected in what way. And through the <code>World</code> class and the <code>Layer_info</code> objects stored there, we can also determine <em>which</em> layers contain values that are linked to these affected elements. But the decision <em>how</em> values should be changed depends on the semantics of the concrete layer, which weâ€™ll store in the <code>Layer_info</code> as two enumerations, one for each major <em>type</em> of topological change<sup class="footnote" onclick="showFootnote(this)" title="Since I've currently only worked on simulating plate tectonics, the behavior and possible values are based solely on the requirements of that (as well as some educated guesses) and an incomplete understanding of the problem domain, and are as such obviously subject to future change. ">[7]</sup>.</p>

<h3 id="deletion-and-modification">Deletion and Modification</h3>

<p>The first â€“ and easier â€“ of these two covers the case when data is completely invalidated. Either because the part of the mesh that is referenced has been deleted or because the <code>origin()</code>/<code>dest()</code> of an edge changed. And the enum that describes the possible reactions is:</p>
<pre><code class="language-cpp">enum class On_mesh_change {
	keep,            // The value is not changed
	reset_affected,  // The value is reset to its initial value (normally 0)
	reset_all,       // ALL values of the layer are reset
	remove_layer     // The layer is deleted entirely
};
</code></pre>

<h3 id="creation-and-merging">Creation and Merging</h3>

<p>The second enumeration is a <em>tad</em> more complicated, because itâ€™s not used for invalidated or removed elements but to calculate entirely new values.</p>

<p>This one is used every time a new element is inserted (new vertex, faces and edges) by <code>split()</code>, to interpolate its value based on its two neighbors<sup class="footnote" onclick="showFootnote(this)" title="Or only a single neighbor for both sides of the interpolation, if there is no meaningful second neighbor, e.g. for the new faces or the new central edge on a split">[8]</sup>, or when <code>collapse()</code> merged the two vertices of an edge into one<sup class="footnote" onclick="showFootnote(this)" title="The faces and edges are not merged but either remain unchanged or are removed/invalidated, so they are not affected by this setting. ">[9]</sup>:</p>

<pre><code class="language-cpp">enum class Interpolation {
	dont_care,
	reset_affected,
	reset_all,
	remove_layer,
	keep_src,
	keep_dest,
	lerp,
	slerp,
	min_value,
	max_value,
	min_weight,
	max_weight
};
</code></pre>

<p>Because the behavior might not be obvious from their names alone, itâ€™s perhaps better to show what their result would be for different inputs<sup class="footnote" onclick="showFootnote(this)" title="... means the value doesn't matter for the result, i.e. is ignored, or is undefined in the result">[10]</sup>:</p>

<div style="overflow: auto hidden">
  <div style="min-width:46em">

    <table class="bordered">
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
          <th>Src</th>
          <th>Dest</th>
          <th>Weight</th>
          <th>Result</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>dont_care</code></td>
          <td>Donâ€™t set the value</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
        </tr>
        <tr>
          <td><code>reset_affected</code></td>
          <td>Reset to initial value (usually 0)</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>0.0</td>
        </tr>
        <tr>
          <td><code>reset_all</code></td>
          <td>Reset all values in the layer</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>0.0</td>
        </tr>
        <tr>
          <td><code>remove_layer</code></td>
          <td>Remove the entire layer</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>â€¦</td>
        </tr>
        <tr>
          <td><code>keep_src</code></td>
          <td>Always keep the source value</td>
          <td>0.1</td>
          <td>â€¦</td>
          <td>â€¦</td>
          <td>0.1</td>
        </tr>
        <tr>
          <td><code>keep_dest</code></td>
          <td>Always keep the destination value</td>
          <td>â€¦</td>
          <td>0.9</td>
          <td>â€¦</td>
          <td>0.9</td>
        </tr>
        <tr>
          <td><code>lerp</code></td>
          <td>Linearly interpolate between the two values</td>
          <td>0.1</td>
          <td>0.9</td>
          <td>0.5</td>
          <td>0.1+0.5*(0.9-0.1) = 0.5</td>
        </tr>
        <tr>
          <td><code>slerp</code></td>
          <td>Linearly interpolate on a sphere <sup class="footnote" onclick="showFootnote(this)" title="This works by first linearly interpolating the two values, normalizing the result and multiplying it with the linearly interpolated length of the two initial values. Because of this, this value only makes sense for vectors (Vec2 and Vec3) ">[11]</sup></td>
          <td>(1,0,0)</td>
          <td>(0,1,0)</td>
          <td>0.5</td>
          <td>(0.71, 0.71, 0)</td>
        </tr>
        <tr>
          <td><code>min_value</code></td>
          <td>Keep the smaller of the two values</td>
          <td>0.1</td>
          <td>0.9</td>
          <td>â€¦</td>
          <td>0.1</td>
        </tr>
        <tr>
          <td><code>max_value</code></td>
          <td>Keep the larger of the two values</td>
          <td>0.1</td>
          <td>0.9</td>
          <td>â€¦</td>
          <td>0.9</td>
        </tr>
        <tr>
          <td><code>min_weight</code></td>
          <td>Keep the value with the smallest weight</td>
          <td>0.1</td>
          <td>0.9</td>
          <td>0.6</td>
          <td>0.1</td>
        </tr>
        <tr>
          <td><code>max_weight</code></td>
          <td>Keep the value with the largest weight</td>
          <td>0.1</td>
          <td>0.9</td>
          <td>0.6</td>
          <td>0.9</td>
        </tr>
      </tbody>
    </table>

  </div>
</div>

<p>And finally here are some examples, that show how this functionality will be used in practice:</p>
<pre><code class="language-cpp">// The layer that stores the vertex positions.
// Since all points have to be located on the surface of a sphere, 
//   the interpolation has to make sure that they stay there
constexpr auto position_info  = Layer_info&lt;Vec3, Layer_type::vertex&gt;("position")
								.interpolation(Interpolation::slerp)
								.on_mesh_change(On_mesh_change::reset_affected);
								
// Each vertex is also assigned to a specific tectonic plate, by giving it an ID.
// Since we can't interpolate between IDs, we instead pick the one of the nearest vertex
constexpr auto layer_plate_id = Layer_info&lt;std::int32_t, Layer_type::vertex&gt;("plate_id")
								.interpolation(Interpolation::max_weight)
								.on_mesh_change(On_mesh_change::reset_affected);
                                        
// We also need to memorize the distance between sub-plates/vertices.
// These are assigned to the edges between vertices (independent of their direction).
// But if the topology changes we can't recompute them with the logic outlined above,
//   so instead they are reset to a known value (-1.0) and recomputed as needed.
constexpr auto layer_distance = Layer_info&lt;float, Layer_type::edge_primal&gt;("plate_distance")
								.initial(-1.f)
								.on_mesh_change(On_mesh_change::reset_affected)
								.interpolation(Interpolation::reset_affected);
</code></pre>

<h2 id="summary">Summary</h2>

<p>That should be all fundamentals we require for now and our current architecture looks something like this:</p>
<ul>
  <li>We have a <code>Mesh</code> class that describes the topology of our generated world as a delaunay triangulation, in terms of vertices, faces and edges â€“ i.e. a set of places and information how they are connected â€“ and allows us to traverse and modify it</li>
  <li>All the actual information is stored in <code>Layer</code> objects â€“ whose properties are defined in <code>Layer_info</code> structures â€“ that contain things like the position of our vertices, their elevation above sea level, their temperature, â€¦</li>
  <li>Both of these are combined into a <code>World</code> class that manages them, e.g. resizes and modifies layers if the topology changes</li>
  <li>The code that actually generates the world consists of independent modules that are sequentially invoked on the same <code>World</code> object to incrementally fill it with more information and advance the simulation
    <ul>
      <li>So the only way for these modules to interact with each other is through layers or modifying the mesh itself</li>
      <li>These will also be the main focus of the next posts, where weâ€™ll dive into the actual plate simulation</li>
    </ul>
  </li>
</ul>

:ET