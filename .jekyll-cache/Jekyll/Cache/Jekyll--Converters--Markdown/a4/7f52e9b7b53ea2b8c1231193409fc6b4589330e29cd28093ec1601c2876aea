I"~z<p>Before we can get started with the actual generation/<wbr />simulation algorithms we first need to decide how to store our data, i.e. how the world is represented in the data-model. Given that its not clear what algorithms we will use later and what their requirements will be, we’ll want to choose an extensible model, that won’t restrict our options later.</p>

<p>There is however one decision we need to make right now, and that is what kind shapes we want to support. As said in the previous post I want to focus on spherical worlds, seeing as the real world is (nearly) spherical<sup class="footnote" onclick="showFootnote(this)" title="[citation needed]">[1]</sup> and I want to be able to directly compare it with my results. Since we are – at least at the current scale – only interested in the information on the surface of our world, this means that we need an efficient way to store information for points on the surface of a sphere.</p>

<!--more-->

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/Triangles_(spherical_geometry).jpg" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/Triangles_(spherical_geometry).jpg" alt="" />
	</a>
  <figcaption>On a Sphere, triangles can have more than one right angle <sup><a href="https://commons.wikimedia.org/wiki/File:Triangles_(spherical_geometry).jpg">[source]</a></sup></figcaption>
</figure>

<p>Working on the surface of a sphere brings with it a number of interesting problems<sup class="footnote" onclick="showFootnote(this)" title="which is the reason most sane projects try to avoid it by using a flat surface for their worlds ">[2]</sup>, because its not a euclidean space we are used to from school but a elliptic one. This doesn’t realy effect us at human scales but the scale of continents we will need to take that into account when moving points on the surface and calculating distances and angles.
Another problem with using a sphere for our world is that it limits our possible data structures, because a sphere can’t be projected onto a flat surface without introducing distortions or other artifacts. Because of that simply projecting a bitmap texture onto the sphere is not realy a practical solution.</p>

<p>But based on the other projects I’ve looked at and my requirements, a triangle mesh is the obvious choice, anyway. Structured Grids like bitmaps/2D-Arrays often suffer from artifacts, either from discretisation problems or other limitations, that are less obvious on unstructured grids. A triangle mesh is also promising data structure, because it extremly flexible as far as the resolution is concerned which will be required to support the relativly large detailed worlds I’m looking for.</p>

<p>So the data structure of choice will be a triangle mesh, to represent a Delauny triangulation (as well as their dual-graph the voronoi diagram) with a variable resolution based on local detail requirements.</p>

<p><br style="clear: both" /></p>

<h2 id="mesh-data-structure-quad-edges">Mesh data structure: Quad-Edges</h2>

<p>The next question is: How do we store this triangle mesh?</p>

<p>The simple option would be an array of faces, each containing the connected vertices. But to actually work with the mesh we will need an efficient way to traverse it, i.e. answer questions like “what other vertices/faces are connected to this vertex?”. Other common data structures for triangle meshes, that solve this problem, are directed edges, winged edges and half-edges.</p>

<p>But the data structure I’ve decided on are <a href="http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html">quad-edges</a>, first described by Jorge Stolfi and Leonidas J. Guibas in 1985. Their main benefit is, that they model the primal triangle mesh, as well as its dual (voronoi diagram) at the same time. This means that we can traverse both and naturaly switch between them if our algorithm requires it. Furthermore quad-edges can answer many questions about the topology in constant time and often with just a simple bit-operation or by dereferencing a single pointer. And in spite of all that their memory layout can be quite compact, which will be important for larger worlds.</p>

<p>The three main concepts are the same as for any mesh: vertices, faces and edges. Vertices are points on the surface and the structure where we will store most of our information like elevation. Two vertices can be connected by an edge and three connected vertices form a single triangular face.</p>

<p>In addition to this <em>primal mesh</em>, we also want to work with its <em>dual</em>. Here vertices and faces switch places, that is each face in the primal mesh is a vertex in the dual mesh, which are connected into voronoi cells with one of the primal vertices inside. As we can see in the image on the right, for each edge in the primal mesh (grey) the dual mesh contains an edge that connects the face on the left and on the right side of it. But the edges and vertices at the boundary are a bit of an <em>edge case</em> and form voronoi cells that are infinitly large. Luckily that is a case we can ignore for now, because our sphere is a closed mesh without any holes or boundaries.</p>

<figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/delauny_voronoi.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/delauny_voronoi.png" alt="" />
	</a>
  <figcaption>A delaunay triangulation (grey) of the vertices (red) and its dual, consisting of the circumcenters of the faces (blue) and connecting edges (cyan), forming the voronoi cells.</figcaption>
</figure>

<p>Of these three concepts the most important one for our quad-edge data structure is (as the name suggest) the edge. But the edges we are using here are <em>directed</em>, which means they know which vertex they are coming from, which one they are going to and which faces are on their left/right side. And we have not just one edge for each connected vertex but four, that form a quad-edge. Beside these information, we only need one other datum to describe the complete topology: The outgoing edges from each vertex and face. And we store these as linked-lists of edges, where each edge knows the next edge around its origin (also called an edge-loop).</p>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/directed_edge.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/directed_edge.png" alt="" />
	</a>
  <figcaption>Each edge <code class="highlighter-rouge">e</code> knows its origin/destination vertex, as well as which face is on its left/right side.<br /> Or origin/destination faces and left/right vertices for edges of the dual mesh.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/quad_edge.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/quad_edge.png" alt="" />
	</a>
  <figcaption>Each edge also knows the other edges that are part of the same quad-edge, which we can access by rotating the edge counter clockwise.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/edge_loop.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/edge_loop.png" alt="" />
	</a>
  <figcaption>Finally, each edge knows the next edge, when rotating counter-clockwise around its vertex/face of origin.</figcaption>
</figure>

</div>

<p>This might look like a lot of information, but as we will see most of it is redundant and doesn’t need to stored direcly.</p>

<p>The information above describes the complete topology of our mesh, which we can access using the following basic operations:</p>
<ul>
  <li><code>rot(e)</code>: Gives us the next edge in a quad-edge. As each quad-edge consists of four edges, the result of the fourth rotation is our initial edge, again.</li>
  <li><code>sym(e)</code>: Gives us the edge that points in the opposite direction. So its the same as rotating the edge twice.</li>
  <li><code>origin(e)</code>: Gives us the origin of an edge (either a vertex in the primal or a face in the dual mesh).</li>
  <li><code>dest(e)</code>: Gives us the destionation of an edge.</li>
  <li><code>left(e)</code>: Gives us the face/vertex on the left side of the edge.</li>
  <li><code>right(e)</code>: Gives us the face/vertex on the right side of the edge.</li>
  <li><code>origin_next(e)</code>: Gives us the next edge in counter-clockwise direction around the origin of an edge. Like <code>rot(e)</code> this will loop back into itself after we have visited every outgoing edge from the origin.</li>
</ul>

<p>But we can also combine them into more complex operations to traverse the mesh:</p>
<ul>
  <li><code>dest_next(e)</code>: Same as <code>origin_next(e)</code> but gives us the next edge around the destination instead.</li>
  <li><code>left_next(e)</code>: Gives us the next edge rotating around the left face, i.e. <code>left(e)</code> will return the same value and the origin of the returned edge is our destionation.</li>
  <li><code>right_next(e)</code>: Same as <code>left_next(e)</code> but rotates around the right face.</li>
</ul>

<p>As we’ve seen all operations above always rotate counter-clockwise. So the final operations we will define are variants of the above, that rotate in the opposite direction:</p>
<ul>
  <li><code>inv_rot(e)</code></li>
  <li><code>origin_prev(e)</code></li>
  <li><code>left_prev(e)</code></li>
  <li><code>right_prev(e)</code></li>
</ul>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/origin_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/origin_next.png" alt="" />
	</a>
  <figcaption><code class="highlighter-rouge">origin_next(e)</code> gives allows us to iterate over all edges around a vertex or face. As with all operations the direction is counter-clockwise and <code class="highlighter-rouge">origin_prev(e)</code> can be used for clockwise iteration.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/dest_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/dest_next.png" alt="" />
	</a>
  <figcaption>Similary, <code class="highlighter-rouge">dest_next(e)</code> can be used to iterate over all edges with a given destionation.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/left_right_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/left_right_next.png" alt="" />
	</a>
  <figcaption>And finally <code class="highlighter-rouge">left_next(e)</code> and <code class="highlighter-rouge">right_next(e)</code> can be used to iterate over all edges that are part of a given face.</figcaption>
</figure>

</div>

<p>There is one more operation defined by the paper, that we will ignore here: <code>flip(e)</code> returns the edge as seen from the other side of the polygon, i.e. the origin and destination stay the same but the left and right face are swapped. This operation is usefull because quad-edges can actually represent any <a href="https://sinestesia.co/blog/tutorials/non-manifold-meshes-and-how-to-fix-them/">manifold</a> polygon<sup class="footnote" onclick="showFootnote(this)" title="Which means they have to locally resemble n-dimensional Euclidean space. For our use-case that mostly just means that every edge has exactly two faces (left and right). Of course, this technically also means that 2D planes are not supported (because of the edges at their boundary) but as we will see later, we can solve this by just connecting the boundary edges to each other to close the mesh ">[3]</sup>, including non-triangular meshes and even non-orientable surfaces<sup class="footnote" onclick="showFootnote(this)" title="e.g. Möbius strips ">[4]</sup> and don’t have an inherent preference for a specific side of the polygon. But we don’t realy need that sort of flexibility for our endevor, which is describing the topology of the surface of a sphere (and maybe later other simple shapes) and would rather trade it for some simplicity further down the road. So what we will do instead is drop this operation and only work on one side of the polygon, defined by a consistent counter-clockwise winding order.</p>

<h2 id="implementation">Implementation</h2>

<p>Now that we have seen how quad-edges describe the topology and what operations we need, we can start with the interesting part: Implementing it and looking for potential optimizations</p>

<p>First lets reiterate what we need to store:</p>
<ol>
  <li>For each vertex: one outgoing edge (<code>origin(e)</code> is our vertex)</li>
  <li>For each face: one edge going counter-clockwise around the face (<code>left(e)</code> is our face)</li>
  <li>For each edge:
    <ol>
      <li>Its siblings, i.e. the three other edges that are part of the same quad-edge.</li>
      <li>The next edge, iterating counter-clockwise around its origin (<code>origin_next(e)</code>).</li>
      <li>The origin/destination vertex and left/right face. Or the origin/destination face and left/right vertex for dual-edges, respectivly.</li>
    </ol>
  </li>
</ol>

<p>One thing we can drop immediately from that list is most of 3.3. Because each edge already knows the other edges of the quad-edge, we only realy need to store the origin vertex/face of each edge. Everything else can be reconstructed from just these two:</p>
<ul>
  <li><code>destination(e) == origin(sym(e))</code></li>
  <li><code>left(e) == origin(inv_rot(e))</code></li>
  <li><code>right(e) == origin(rot(e))</code></li>
</ul>

<p>We could do something similar for the referces to an edges siblings:</p>
<ul>
  <li><code>sym(e) == rot(rot(e))</code></li>
  <li><code>inv_rot(e) == rot(rot(rot(e)))</code></li>
</ul>

<p>But, as we will see next, that doesn’t realy buy us anything because we can get rid of 3.1 entirely.</p>

<p>If we would transfer that naivly to C++ it could look something like this:</p>

<pre><code class="language-cpp">struct Vertex {
	Edge*    outgoing_edge;        // 1.
};
struct Face {
	Edge*    ccw_edge;             // 2.
};
struct Edge {
	std::array&lt;Edge*, 4&gt; siblings; // 3.1.
	Edge*                next;     // 3.2.
};

// we need two separat types for edges, because the 
//   type of the origin is different for primal and dual edges
struct Primal_edge : Edge {
	Vertex* origin;                // 3.3.
};
struct Dual_edge : Edge {
	Face* origin;                  // 3.3.
};

struct Mesh {
	// the actual data, that is referenced by the pointers above
	std::vector&lt;Vertex&gt;      vertices;
	std::vector&lt;Face&gt;        faces;
	std::vector&lt;Primal_edge&gt; primal_edges;
	std::vector&lt;Dual_edge&gt;   dual_edges;
};
</code></pre>

<p><br /></p>

<p>As this just defines the topology, we still need a way to store our actual data, like vertex positions or elevations. We could just add those to the struct as additional member variables, but that would mean that we need to modify them each time we implement a new generation algorithm, which would make future expansion more difficult<sup class="footnote" onclick="showFootnote(this)" title="Or in other words: Such a construct would violate the open–closed principle.">[5]</sup>. So instead we will give each vertex/face/edge a unique ID, that we can than later use as a key to reference our data.</p>

<p>To define these IDs we will just use their index position inside the <code>std::vector</code> that contains them. For vertices and faces this will work without any problems, but for edges we also need to differenciate between primal and dual edges. To solve this problem, we will resort to the age old tradition of <em>stealing every bit that isn’t nailed down</em>. To be precise we will use the most significant bit of our ID to decide if it references a primal or dual edge<sup class="footnote" onclick="showFootnote(this)" title="Sadly this will leave us with a maximum of only 2'147'483'647 edges. But I think that loss will be survivable (for now).">[6]</sup>.</p>

<p>If we visualize that structure we see another interesting effect. Because each edge always belongs to a quad-edge, if we add a new edge to our mesh we will always need to create 4 edges (2 primal + 2 dual). So if we store and reference our edges as described above, we can find the siblings of an edge just by modifing their index, without storing any additional data.</p>

<pre><code class="language-plaintext">                       quad edge 1               quad edge 2
                           ︷                        ︷
              ╭────────────┬────────────┬────────────┬────────────┬────────────╮
primal_edges: │     e0     │     e1     │     e2     │     e3     │     ...    │
              ╰────────────┴────────────┴────────────┴────────────┴────────────╯
              ╭────────────┬────────────┬────────────┬────────────┬────────────╮
dual_edges:   │     e0     │     e1     │     e2     │     e3     │     ...    │
              ╰────────────┴────────────┴────────────┴────────────┴────────────╯

Edge-index bits:
       ╭──┬──┬──┬──┬───┬──┬──┬──┬──╮
Bit:   │31│30│29│28│...│ 3│ 2│ 1│ 0│
       ╞══╪══╪══╪══╪═══╪══╪══╪══╪══╡
Value: │ 1│ 0│ 1│ 1│...│ 1│ 0│ 0│ 1│
       ╰──┴──┴──┴──┴───┴──┴──┴──┴──╯
         ↑                        ↑ 
         0 = primal edge          0 = 1. edge of quad-edge
         1 = dual edge            1 = 3. edge of quad-edge (== sym(e) == rot(rot(e)))
</code></pre>

<p>The 31st bit is reserved, so we can decide if the edge belongs to the primal mesh or its dual and the rest is used as the index into the respective vector. But because we allocate the edges continously, they always come in pairs inside each vector and we can switch between them just by flipping the 0th bit of index. What this means is that we can not only drop the <code>siblings</code> member but that we can actually calculate <code>rot(e)</code>, <code>sym(e)</code> and <code>inv_rot(e)</code> using relativly simple bit-wise math instead of chasing pointers!</p>

<p>Since we are already stealing parts of our indices, we will reserve one more value from each as an identifier<sup class="footnote" onclick="showFootnote(this)" title="Which will bring our total number of possible edges down to a disapointing 2'147'483'645... ">[7]</sup> for invalid or unset edges, vertices and faces. These will be important later to define boundary edges or incomplete meshes during construction. But they also allow as to “delete” elements from the mesh. Because the index of an element is also used to reference it, we can’t just remove them from the vector, because that would move all later elements, changing their index. Instead we utilize the invalid IDs to leave “holes” in the vector, that we can skip during processing and fill in later with new vertices/faces/edges.</p>

<p>And that’s it, for the most part. As a last step we will just sprinkle a bit of data-oriented design over our structure, by moving our data from the <code>Vertex</code>/<code>Face</code>/<code>Edge</code> struct directly into separat vector in the Mesh. That doesn’t change much in our case, as our structs were already extremly small and simple, but could be a wee bit fast for some cases<sup class="footnote" onclick="showFootnote(this)" title="e.g. if we just need to follow the next-Pointer of an edge but don't need the origin of the edge ">[8]</sup>. And it also simplifies our structs a bit, because we don’t need separat structs for <code>Primal_edge</code> and <code>Dual_edge</code> or inheritance anymore. And finally it frees up <code>Face</code>, <code>Vertex</code> and <code>Edge</code> as type names, that we can than use as type-safe ID-wrappers.<sup class="footnote" onclick="showFootnote(this)" title="The actual implementation follows the same structure, but is a bit more complex because it needs to handle &quot;holes&quot; in the vectors left by modifications. And its a bit less readable because I'm using a thin C-API over my C++ implementation to achive ABI stability. And I've also left out any constructors, operators and methods here. ">[9]</sup></p>

<pre><code class="language-cpp">struct Face {
	uint32_t id;
};
struct Vertex {
	uint32_t id;
};
struct Edge {
	uint32_t mask;
};

class Mesh {
  private:
	std::vector&lt;Edge&gt;   vertex_edges_;
	std::vector&lt;Edge&gt;   face_edges_;
	
	std::vector&lt;Vertex&gt; primal_edge_origin_;
	std::vector&lt;Edge&gt;   primal_edge_next_;
	std::vector&lt;Face&gt;   dual_edge_origin_;
	std::vector&lt;Edge&gt;   dual_edge_next_;
};
</code></pre>

<h3 id="operations">Operations</h3>

<p>We’ve already seen that we can implement <code>rot()</code>, <code>sym()</code> and <code>inv_rot()</code> as bit-wise operations on the ID, so that is the first thing we will implement:<sup class="footnote" onclick="showFootnote(this)" title="All of these methods and constructors could and should of course be constexpr and are in the actual implementation. ">[10]</sup></p>

<pre><code class="language-cpp">inline constexpr auto edge_type_bit = uint32_t(1) &lt;&lt; 31u;

struct Edge {
	uint32_t mask;
	
	// The default constructor sets all bits to 1,
	//   which is our representation for an invalid edge
	Edge() : mask{~uint32_t(0)} {}
	
	// And we also have constructors that take a mask 
	//   or construct a new one from an index and a bool 
	//   (i.e. set the highest bit if its a dual edge)
	Edge(uint32_t mask) : mask{mask} {}
	Edge(bool dual, uint32_t index)
	  : mask{dual ? (index | edge_type_bit) : index} {
	}
	
	// If we need the actual index, we have to unset the highest bit
	uint32_t index()const   { return mask &amp; ~edge_type_bit; }
	// And to decide if an edge belongs to the dual or primal mesh
	//   we can just shift it, so its highest bit is the only one left
	bool     is_dual()const { return mask &gt;&gt; 31u; }

	// As we have seen above, the two primal/dual edges that
	//   belong to the same quad edge are always at an odd/even
	//   index and right beside each other.
	// So we just need to xor the least significant 
	//   bit to switch between them
	Edge sym()const     { return { mask ^ 1u}; }
	
	// rot and inv_rot are a bit more complex, because we need to change both bits.
	// First we always need to xor the highest bit, as rot always 
	//   alternates between dual and primal edges.
	// And we also need to change the lowest bit, which we will do
	//   with the second xor (see graphic below)
	Edge rot()const     { return {(mask ^ edge_type_bit) ^  is_dual()}; }
	Edge inv_rot()const { return {(mask ^ edge_type_bit) ^ (is_dual() ^ 1u)}; }
	
	// And there is one last operation, we haven't talked about,
	//   which allows us to get the first edge of a quad-edge
	Edge base()const    { return { mask &amp; ~(edge_type_bit | 1u)}; }
</code></pre>

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/quad_edge/rot_math.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/rot_math.png" alt="" />
	</a>
  <figcaption></figcaption>
</figure>

<p style="height:12em; display: table-cell; vertical-align: middle;">
To implement the rotate operation, we need to change both the most and least significant bit. The most significant bit alternates between 0 and 1 as we alternate between primal and dual edges. But the least significant bit only changes every two steps. To realize this, its change is dependent on the most significant bit, i.e. we only alternate it if we rotate from a dual to a primal edge.
</p>
<p><br style="clear:both" /></p>

<p>The next step are the <code>origin(e)</code>/<code>dest(e)</code>/… operations to get the surounding vertices and faces of an edge. The functions to get the origin vertex/face are relativly simple, as we just need to check if the operation is valid for this type of edge (primal vs. dual) and access the corrosponding vector in the <code>Mesh</code> struct. And for the destionation and the left/right face we just need to rotate the edge appropiatly beforehand and than get the origin of the result.</p>
<pre><code class="language-cpp">	Vertex origin(const Mesh&amp; mesh)const {
		assert(!is_dual());
		return mesh.primal_edge_origin_.at(mask);
	}
	Vertex dest(const Mesh&amp; mesh)const {
		return sym().origin(mesh);
	}
	
	Face origin_face(const Mesh&amp; mesh)const {
		assert(is_dual());
		return mesh.dual_edge_origin_[index()];
	}
	Face dest_face(const Mesh&amp; mesh)const {
		return sym().origin_face(mesh);
	}
	
	Face left(const Mesh&amp; mesh)const {
		return inv_rot().origin_face(mesh);
	}
	Face right(const Mesh&amp; mesh)const {
		return rot().origin_face(mesh);
	}
</code></pre>

<p>Next are the function to actually traverse the mesh. <code>origin_next(e)</code> is again quite simple – determine the correct vector based on the type of the edge and load the corresponding next pointer – but implementing all the other in-terms-of it is a bit more complex and perhaps needs a bit of visualization:</p>

<pre><code class="language-cpp">	Edge origin_next(const Mesh&amp; mesh)const {
		return is_dual() ? mesh.dual_edge_next_.at(index())
		                 : mesh.primal_edge_next_.at(index());
	}
	Edge origin_prev(const Mesh&amp; mesh)const {
		return rot().origin_next(mesh).rot();
	}
	Edge dest_next(const Mesh&amp; mesh)const {
		return sym().origin_next(mesh).sym();
	}
	Edge dest_prev(const Mesh&amp; mesh)const {
		return inv_rot().origin_next(mesh).inv_rot();
	}
	Edge left_next(const Mesh&amp; mesh)const {
		return inv_rot().origin_next(mesh).rot();
	}
	Edge left_prev(const Mesh&amp; mesh)const {
		return origin_next(mesh).sym();
	}
	Edge right_next(const Mesh&amp; mesh)const {
		return rot().origin_next(mesh).inv_rot();
	}
	Edge right_prev(const Mesh&amp; mesh)const {
		return sym().origin_next(mesh);
	}
};
</code></pre>

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/quad_edge/origin_prev.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/origin_prev.png" alt="" />
	</a>
  <figcaption></figcaption>
</figure>

<p>One example for the methods above, that shows how <code>origin_prev()</code> can be implemented in terms of <code>origin_next()</code>.</p>

<p>The key here is that we first rotate the edge, to get the dual edge that points from the right to the left face. Just like with primal edges we can use <code>origin_next()</code> to get the next (counter-clockwise) edge around the origin, but for dual edges that origin is a face instead of a vertex. So when we rotate our dual edge, we get the dual edge that point “through” the next edge of the right face or in other words <code>origin_prev()</code> of our original mesh. And to get this primal edge, we then just need to rotate the dual edge again.</p>

<p><br style="clear:both" /></p>

<h3 id="higher-level-abstractions">Higher level abstractions</h3>

<p>Based on the relativly simple operations, we have seen so far, we can now construct higher level abstraction to navigate the topology. One operation we need relativly often is iterating over every neighbor of a given vertex<sup class="footnote" onclick="showFootnote(this)" title="i.e. all vertices that share an edge with the given vertex">[11]</sup>, which can be implemented as:</p>

<pre><code class="language-cpp">// get any edge that points away from the vertex
auto edge = vertex.edge(mesh);
auto e    = edge;
do {
	// get the destination vertex of the current edge
	auto v = e.dest(mesh);
	// use v
	
	// get the next (CCW) edge
	e = e.origin_next(mesh);
	
	// if the next edge is the one we started with,
	//   we have visited all edges and can stop
} while(e!=edge);
</code></pre>

<p>// the actual API also contains iterators that 
//   wrap these common operations like this</p>
<pre><code class="language-cpp">for(auto v : mesh.neighbors(vertex)) {
	// use v
}
</code></pre>

<p>TODO: modification operations in next blog post (adding faces, flip/split/collapse edges)</p>

<h2 id="positions-elevations-and-other-data-layers">Positions, Elevations and other data layers</h2>
<p>TODO: Mesh contains just the topological infomations and no actual data like positions =&gt; those are all stored in data-layers linked to different parts of the mesh</p>
<ul>
  <li>Per-Vertex/Face/Edge Data
    <ul>
      <li>e.g. position, elevation, water-volume, temperatures, distance, forces, …</li>
      <li>edges split into primal/dual</li>
      <li>support directed and undirected edges</li>
      <li>implemented as continous array of elements (index = edge/vertex/face ID)</li>
    </ul>
  </li>
  <li>Unstructured Data (e.g. Settlements, POIs, People?) =&gt; JSON-like map-structure</li>
</ul>

<p>TODO: World structure that contains both</p>
<ul>
  <li>mesh (vertices + edges)</li>
  <li>layers (created/updated by modules)</li>
  <li>copy-on-write for easy undo/redo and parallel processing</li>
</ul>

<pre><code class="language-cpp">constexpr auto position_layer = Layer_info&lt;Vec3, Layer_type::vertex&gt;("position");
		
auto [positions] = world.lock_layer(position_layer);

positions[Vertex(42)] = Vec3{10.f, -2.f, 3.f};
</code></pre>

<pre><code class="language-cpp">constexpr auto distance_layer = Layer_info&lt;float, Layer_type::edge_primal&gt;("plate_distance")
                                .initial(-1.f);
</code></pre>

:ET