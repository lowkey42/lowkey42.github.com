I"˓<p>Before we can get started with the actual generation/<wbr />simulation algorithms we first need to decide how to store our data, i.e. how the world is represented in the data-model. Given that its not clear what algorithms we will use later and what their requirements will be, we’ll want to choose an extensible model, that won’t restrict our options later.</p>

<p>There is however one decision we need to make right now, and that is what kind shapes we want to support. As said in the previous post I want to focus on spherical worlds, seeing as the real world is (nearly) spherical<sup class="footnote" onclick="showFootnote(this)" title="[citation needed]">[1]</sup> and I want to be able to directly compare it with my results. Since we are – at least at the current scale – only interested in the information on the surface of our world, this means that we need an efficient way to store information for points on the surface of a sphere.</p>

<!--more-->

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/Triangles_(spherical_geometry).jpg" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/Triangles_(spherical_geometry).jpg" alt="" />
	</a>
  <figcaption>On a Sphere, triangles can have more than one right angle <sup><a href="https://commons.wikimedia.org/wiki/File:Triangles_(spherical_geometry).jpg">[source]</a></sup></figcaption>
</figure>

<p>Working on the surface of a sphere brings with it a number of interesting problems<sup class="footnote" onclick="showFootnote(this)" title="which is the reason most sane projects try to avoid it by using a flat surface for their worlds ">[2]</sup>, because its not a euclidean space we are used to from school but a elliptic one. This doesn’t realy effect us at human scales but the scale of continents we will need to take that into account when moving points on the surface and calculating distances and angles.
Another problem with using a sphere for our world is that it limits our possible data structures, because a sphere can’t be projected onto a flat surface without introducing distortions or other artifacts. Because of that simply projecting a bitmap texture onto the sphere is not realy a practical solution.</p>

<p>But based on the other projects I’ve looked at and my requirements, a triangle mesh is the obvious choice, anyway. Structured Grids like bitmaps/2D-Arrays often suffer from artifacts, either from discretisation problems or other limitations, that are less obvious on unstructured grids. A triangle mesh is also promising data structure, because it extremly flexible as far as the resolution is concerned which will be required to support the relativly large detailed worlds I’m looking for.</p>

<p>So the data structure of choice will be a triangle mesh, to represent a Delauny triangulation (as well as their dual-graph the voronoi diagram) with a variable resolution based on local detail requirements.</p>

<p><br style="clear: both" /></p>

<h2 id="mesh-data-structure-quad-qdges">Mesh data structure: quad-qdges</h2>

<p>The next question is: How do we store this triangle mesh?</p>

<p>The simple option would be an array of faces, each containing the connected vertices. But to actually work with the mesh we will need an efficient way to traverse it, i.e. answer questions like “what other vertices/faces are connected to this vertex?”. Other common data structures for triangle meshes, that solve this problem, are directed edges, winged edges and half-edges.</p>

<p>But the data structure I’ve decided on are <a href="http://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html">quad-edges</a>, first described by Jorge Stolfi and Leonidas J. Guibas in 1985. Their main benefit is, that they model the primal triangle mesh, as well as its dual (voronoi diagram) at the same time. This means that we can traverse both and naturaly switch between them if our algorithm requires it. Furthermore quad-edges can answer many questions about the topology in constant time and often with just a simple bit-operation or by dereferencing a single pointer. And in spite of all that their memory layout can be quite compact, which will be important for larger worlds.</p>

<p>The three main concepts are the same as for any mesh: vertices, faces and edges. Vertices are points on the surface and the structure where we will store most of our information like elevation. Two vertices can be connected by an edge and three connected vertices form a single triangular face.</p>

<p>In addition to this <em>primal mesh</em>, we also want to work with its <em>dual</em>. Here vertices and faces switch places, that is each face in the primal mesh is a vertex in the dual mesh, which are connected into voronoi cells with one of the primal vertices inside. As we can see in the image on the right, for each edge in the primal mesh (grey) the dual mesh contains an edge that connects the face on the left and on the right side of it. But the edges and vertices at the boundary are a bit of an <em>edge case</em> and form voronoi cells that are infinitly large. Luckily that is a case we can ignore for now, because our sphere is a closed mesh without any holes or boundaries.</p>

<figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/delauny_voronoi.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/delauny_voronoi.png" alt="" />
	</a>
  <figcaption>A delaunay triangulation (grey) of the vertices (red) and its dual, consisting of the circumcenters of the faces (blue) and connecting edges (cyan), forming the voronoi cells.</figcaption>
</figure>

<p>Of these three concepts the most important one for our quad-edge data structure is (as the name suggest) the edge. But the edges we are using here are <em>directed</em>, which means they know which vertex they are coming from, which one they are going to and which faces are on their left/right side. And we have not just one edge for each connected vertex but four, that form a quad-edge. Beside these information, we only need one other datum to describe the complete topology: The outgoing edges from each vertex and face. And we store these as linked-lists of edges, where each edge knows the next edge around its origin (also called an edge-loop).</p>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/directed_edge.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/directed_edge.png" alt="" />
	</a>
  <figcaption>Each edge <code class="highlighter-rouge">e</code> knows its origin/destination vertex, as well as which face is on its left/right side.<br /> Or origin/destination faces and left/right vertices for edges of the dual mesh.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/quad_edge.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/quad_edge.png" alt="" />
	</a>
  <figcaption>Each edge also knows the other edges that are part of the same quad-edge, which we can access by rotating the edge counter clockwise.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/edge_loop.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/edge_loop.png" alt="" />
	</a>
  <figcaption>Finally, each edge knows the next edge, when rotating counter-clockwise around its vertex/face of origin.</figcaption>
</figure>

</div>

<p>This might look like a lot of information, but as we will see most of it is redundant and doesn’t need to stored direcly.</p>

<p>The information above describes the complete topology of our mesh, which we can access using the following basic operations:</p>
<ul>
  <li><code>rot(e)</code>: Gives us the next edge in a quad-edge. As each quad-edge consists of four edges, the result of the fourth rotation is our initial edge, again.</li>
  <li><code>sym(e)</code>: Gives us the edge that points in the opposite direction. So its the same as rotating the edge twice.</li>
  <li><code>origin(e)</code>: Gives us the origin of an edge (either a vertex in the primal or a face in the dual mesh).</li>
  <li><code>dest(e)</code>: Gives us the destionation of an edge.</li>
  <li><code>left(e)</code>: Gives us the face/vertex on the left side of the edge.</li>
  <li><code>right(e)</code>: Gives us the face/vertex on the right side of the edge.</li>
  <li><code>origin_next(e)</code>: Gives us the next edge in counter-clockwise direction around the origin of an edge. Like <code>rot(e)</code> this will loop back into itself after we have visited every outgoing edge from the origin.</li>
</ul>

<p>But we can also combine them into more complex operations to traverse the mesh:</p>
<ul>
  <li><code>dest_next(e)</code>: Same as <code>origin_next(e)</code> but gives us the next edge around the destination instead.</li>
  <li><code>left_next(e)</code>: Gives us the next edge rotating around the left face, i.e. <code>left(e)</code> will return the same value and the origin of the returned edge is our destionation.</li>
  <li><code>right_next(e)</code>: Same as <code>left_next(e)</code> but rotates around the right face.</li>
</ul>

<p>As we’ve seen all operations above always rotate counter-clockwise. So the final operations we will define are variants of the above, that rotate in the opposite direction:</p>
<ul>
  <li><code>inv_rot(e)</code></li>
  <li><code>origin_prev(e)</code></li>
  <li><code>left_prev(e)</code></li>
  <li><code>right_prev(e)</code></li>
</ul>

<div class="image_list">

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/origin_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/origin_next.png" alt="" />
	</a>
  <figcaption><code class="highlighter-rouge">origin_next(e)</code> gives allows us to iterate over all edges around a vertex or face. As with all operations the direction is counter-clockwise and <code class="highlighter-rouge">origin_prev(e)</code> can be used for clockwise iteration.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/dest_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/dest_next.png" alt="" />
	</a>
  <figcaption>Similary, <code class="highlighter-rouge">dest_next(e)</code> can be used to iterate over all edges with a given destionation.</figcaption>
</figure>

  <figure class="captioned_image fill_black">
	<a class="open_img" href="/assets/images/quad_edge/left_right_next.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/left_right_next.png" alt="" />
	</a>
  <figcaption>And finally <code class="highlighter-rouge">left_next(e)</code> and <code class="highlighter-rouge">right_next(e)</code> can be used to iterate over all edges that are part of a given face.</figcaption>
</figure>

</div>

<p>There is one more operation defined by the paper, that we will ignore here: <code>flip(e)</code> returns the edge as seen from the other side of the polygon, i.e. the origin and destination stay the same but the left and right face are swapped. This operation is usefull because quad-edges can actually represent any <a href="https://sinestesia.co/blog/tutorials/non-manifold-meshes-and-how-to-fix-them/">manifold</a> polygon<sup class="footnote" onclick="showFootnote(this)" title="Which means they have to locally resemble n-dimensional Euclidean space. For our use-case that mostly just means that every edge has exactly two faces (left and right). Of course, this technically also means that 2D planes are not supported (because of the edges at their boundary) but as we will see later, we can solve this by just connecting the boundary edges to each other to close the mesh ">[3]</sup>, including non-triangular meshes and even non-orientable surfaces<sup class="footnote" onclick="showFootnote(this)" title="e.g. Möbius strips ">[4]</sup> and don’t have an inherent preference for a specific side of the polygon. But we don’t realy need that sort of flexibility for our endevor, which is describing the topology of the surface of a sphere (and maybe later other simple shapes) and would rather trade it for some simplicity further down the road. So what we will do instead is drop this operation and only work on one side of the polygon, defined by a consistent counter-clockwise winding order.</p>

<h2 id="implementation">Implementation</h2>

<p>Now that we have seen how quad-edges describe the topology and what operations we need, we can start with the interesting part: Implementing it and looking for potential optimizations</p>

<p>First lets reiterate what we need to store:</p>
<ol>
  <li>For each vertex: one outgoing edge (<code>origin(e)</code> is our vertex)</li>
  <li>For each face: one edge going counter-clockwise around the face (<code>left(e)</code> is our face)</li>
  <li>For each edge:
    <ol>
      <li>Its siblings, i.e. the three other edges that are part of the same quad-edge.</li>
      <li>The next edge, iterating counter-clockwise around its origin (<code>origin_next(e)</code>).</li>
      <li>The origin/destination vertex and left/right face. Or the origin/destination face and left/right vertex for dual-edges, respectivly.</li>
    </ol>
  </li>
</ol>

<p>One thing we can drop immediately from that list is most of 3.3. Because each edge already knows the other edges of the quad-edge, we only realy need to store the origin vertex/face of each edge. Everything else can be reconstructed from just these two:</p>
<ul>
  <li><code>destination(e) == origin(sym(e))</code></li>
  <li><code>left(e) == origin(inv_rot(e))</code></li>
  <li><code>right(e) == origin(rot(e))</code></li>
</ul>

<p>We could do something similar for the referces to an edges siblings:</p>
<ul>
  <li><code>sym(e) == rot(rot(e))</code></li>
  <li><code>inv_rot(e) == rot(rot(rot(e)))</code></li>
</ul>

<p>But, as we will see next, that doesn’t realy buy us anything because we can get rid of 3.1 entirely.</p>

<p>If we would transfer that naivly to C++ it could look something like this:</p>

<pre><code class="language-cpp">struct Vertex {
	Edge*    outgoing_edge;        // 1.
};
struct Face {
	Edge*    ccw_edge;             // 2.
};
struct Edge {
	std::array&lt;Edge*, 4&gt; siblings; // 3.1.
	Edge*                next;     // 3.2.
};

// we need two separat types for edges, because the 
//   type of the origin is different for primal and dual edges
struct Primal_edge : Edge {
	Vertex* origin;                // 3.3.
};
struct Dual_edge : Edge {
	Face* origin;                  // 3.3.
};

struct Mesh {
	// the actual data, that is referenced by the pointers above
	std::vector&lt;Vertex&gt;      vertices;
	std::vector&lt;Face&gt;        faces;
	std::vector&lt;Primal_edge&gt; primal_edges;
	std::vector&lt;Dual_edge&gt;   dual_edges;
};
</code></pre>

<p><br /></p>

<p>As this just defines the topology, we still need a way to store our actual data, like vertex positions or elevations. We could just add those to the struct as additional member variables, but that would mean that we need to modify them each time we implement a new generation algorithm, which would make future expansion more difficult<sup class="footnote" onclick="showFootnote(this)" title="Or in other words: Such a construct would violate the open–closed principle.">[5]</sup>. So instead we will give each vertex/face/edge a unique ID, that we can than later use as a key to reference our data.</p>

<p>To define these IDs we will just use their index position inside the <code>std::vector</code> that contains them. For vertices and faces this will work without any problems, but for edges we also need to differenciate between primal and dual edges. To solve this problem, we will resort to the age old tradition of <em>stealing every bit that isn’t nailed down</em>. To be precise we will use the most significant bit of our ID to decide if it references a primal or dual edge<sup class="footnote" onclick="showFootnote(this)" title="Sadly this will leave us with a maximum of only 2'147'483'647 edges. But I think that loss will be survivable (for now).">[6]</sup>.</p>

<p>If we visualize that structure we see another interesting effect. Because each edge always belongs to a quad-edge, if we add a new edge to our mesh we will always need to create 4 edges (2 primal + 2 dual). So if we store and reference our edges as described above, we can find the siblings of an edge just by modifing their index, without storing any additional data.</p>

<pre><code class="language-plaintext">                       quad edge 1               quad edge 2
                           ︷                        ︷
              ╭────────────┬────────────┬────────────┬────────────┬────────────╮
primal_edges: │     e0     │     e1     │     e2     │     e3     │     ...    │
              ╰────────────┴────────────┴────────────┴────────────┴────────────╯
              ╭────────────┬────────────┬────────────┬────────────┬────────────╮
dual_edges:   │     e0     │     e1     │     e2     │     e3     │     ...    │
              ╰────────────┴────────────┴────────────┴────────────┴────────────╯

Edge-index bits:
       ╭──┬──┬──┬──┬───┬──┬──┬──┬──╮
Bit:   │31│30│29│28│...│ 3│ 2│ 1│ 0│
       ╞══╪══╪══╪══╪═══╪══╪══╪══╪══╡
Value: │ 1│ 0│ 1│ 1│...│ 1│ 0│ 0│ 1│
       ╰──┴──┴──┴──┴───┴──┴──┴──┴──╯
         ↑                        ↑ 
         0 = primal edge          0 = 1. edge of quad-edge
         1 = dual edge            1 = 3. edge of quad-edge (== sym(e) == rot(rot(e)))
</code></pre>

<p>The 31st bit is reserved, so we can decide if the edge belongs to the primal mesh or its dual and the rest is used as the index into the respective vector. But because we allocate the edges continously, they always come in pairs inside each vector and we can switch between them just by flipping the 0th bit of index. What this means is that we can not only drop the <code>siblings</code> member but that we can actually calculate <code>rot(e)</code>, <code>sym(e)</code> and <code>inv_rot(e)</code> using relativly simple bit-wise math instead of chasing pointers!</p>

<p>Since we are already stealing parts of our indices, we will reserve one more value from each as an identifier<sup class="footnote" onclick="showFootnote(this)" title="Which will bring our total number of possible edges down to a disapointing 2'147'483'645... ">[7]</sup> for invalid or unset edges, vertices and faces. These will be important later to define boundary edges or incomplete meshes during construction. But they also allow as to “delete” elements from the mesh. Because the index of an element is also used to reference it, we can’t just remove them from the vector, because that would move all later elements, changing their index. Instead we utilize the invalid IDs to leave “holes” in the vector, that we can skip during processing and fill in later with new vertices/faces/edges.</p>

<p>And that’s it, for the most part. As a last step we will just sprinkle a bit of data-oriented design over our structure, by moving our data from the <code>Vertex</code>/<code>Face</code>/<code>Edge</code> struct directly into separat vector in the Mesh. That doesn’t change much in our case, as our structs were already extremly small and simple, but could be a wee bit fast for some cases<sup class="footnote" onclick="showFootnote(this)" title="e.g. if we just need to follow the next-Pointer of an edge but don't need the origin of the edge ">[8]</sup>. And it also simplifies our structs a bit, because we don’t need separat structs for <code>Primal_edge</code> and <code>Dual_edge</code> or inheritance anymore. And finally it frees up <code>Face</code>, <code>Vertex</code> and <code>Edge</code> as type names, that we can than use as type-safe ID-wrappers.<sup class="footnote" onclick="showFootnote(this)" title="The actual implementation follows the same structure, but is a bit more complex because it needs to handle &quot;holes&quot; in the vectors left by modifications. And its a bit less readable because I'm using a thin C-API over my C++ implementation to achive ABI stability. And I've also left out any constructors, operators and methods here. ">[9]</sup></p>

<pre><code class="language-cpp">struct Face {
	uint32_t id;
};
struct Vertex {
	uint32_t id;
};
struct Edge {
	uint32_t mask;
};

class Mesh {
  private:
	friend struct Edge;
	
	std::vector&lt;Edge&gt;   vertex_edges_;
	std::vector&lt;Edge&gt;   face_edges_;
	
	std::vector&lt;Vertex&gt; primal_edge_origin_;
	std::vector&lt;Edge&gt;   primal_edge_next_;
	std::vector&lt;Face&gt;   dual_edge_origin_;
	std::vector&lt;Edge&gt;   dual_edge_next_;
};
</code></pre>

<h3 id="operations">Operations</h3>

<p>We’ve already seen that we can implement <code>rot()</code>, <code>sym()</code> and <code>inv_rot()</code> as bit-wise operations on the ID, so that is the first thing we will implement:<sup class="footnote" onclick="showFootnote(this)" title="All of these methods and constructors could and should of course be constexpr and are in the actual implementation. ">[10]</sup></p>

<pre><code class="language-cpp">inline constexpr auto edge_type_bit = uint32_t(1) &lt;&lt; 31u;

struct Edge {
	uint32_t mask;
	
	// The default constructor sets all bits to 1,
	//   which is our representation for an invalid edge
	Edge() : mask{~uint32_t(0)} {}
	
	// And we also have constructors that take a mask 
	//   or construct a new one from an index and a bool 
	//   (i.e. set the highest bit if its a dual edge)
	Edge(uint32_t mask) : mask{mask} {}
	Edge(bool dual, uint32_t index)
	  : mask{dual ? (index | edge_type_bit) : index} {
	}
	
	// If we need the actual index, we have to unset the highest bit
	uint32_t index()const   { return mask &amp; ~edge_type_bit; }
	// And to decide if an edge belongs to the dual or primal mesh
	//   we can just shift it, so its highest bit is the only one left
	bool     is_dual()const { return mask &gt;&gt; 31u; }

	// As we have seen above, the two primal/dual edges that
	//   belong to the same quad edge are always at an odd/even
	//   index and right beside each other.
	// So we just need to xor the least significant 
	//   bit to switch between them
	Edge sym()const     { return { mask ^ 1u}; }
	
	// rot and inv_rot are a bit more complex, because we need to change both bits.
	// First we always need to xor the highest bit, as rot always 
	//   alternates between dual and primal edges.
	// And we also need to change the lowest bit, which we will do
	//   with the second xor (see graphic below)
	Edge rot()const     { return {(mask ^ edge_type_bit) ^  is_dual()}; }
	Edge inv_rot()const { return {(mask ^ edge_type_bit) ^ (is_dual() ^ 1u)}; }
	
	// And there is one last operation, we haven't talked about,
	//   which allows us to get the first edge of a quad-edge
	Edge base()const    { return { mask &amp; ~(edge_type_bit | 1u)}; }
</code></pre>

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/quad_edge/rot_math.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/rot_math.png" alt="" />
	</a>
  <figcaption></figcaption>
</figure>

<p style="height:12em; display: table-cell; vertical-align: middle;">
To implement the rotate operation, we need to change both the most and least significant bit. The most significant bit alternates between 0 and 1 as we alternate between primal and dual edges. But the least significant bit only changes every two steps. To realize this, its change is dependent on the most significant bit, i.e. we only alternate it if we rotate from a dual to a primal edge.
</p>
<p><br style="clear:both" /></p>

<p>The next step are the <code>origin(e)</code>/<code>dest(e)</code>/… operations to get the surounding vertices and faces of an edge. The functions to get the origin vertex/face are relativly simple, as we just need to check if the operation is valid for this type of edge (primal vs. dual) and access the corrosponding vector in the <code>Mesh</code> struct. And for the destionation and the left/right face we just need to rotate the edge appropiatly beforehand and than get the origin of the result.</p>
<pre><code class="language-cpp">	Vertex origin(const Mesh&amp; mesh)const {
		assert(!is_dual());
		return mesh.primal_edge_origin_.at(mask);
	}
	Vertex dest(const Mesh&amp; mesh)const {
		return sym().origin(mesh);
	}
	
	Face origin_face(const Mesh&amp; mesh)const {
		assert(is_dual());
		return mesh.dual_edge_origin_[index()];
	}
	Face dest_face(const Mesh&amp; mesh)const {
		return sym().origin_face(mesh);
	}
	
	Face left(const Mesh&amp; mesh)const {
		return inv_rot().origin_face(mesh);
	}
	Face right(const Mesh&amp; mesh)const {
		return rot().origin_face(mesh);
	}
</code></pre>

<p>Next are the function to actually traverse the mesh. <code>origin_next(e)</code> is again quite simple – determine the correct vector based on the type of the edge and load the corresponding next pointer – but implementing all the other in-terms-of it is a bit more complex and perhaps needs a bit of visualization:</p>

<pre><code class="language-cpp">	Edge origin_next(const Mesh&amp; mesh)const {
		return is_dual() ? mesh.dual_edge_next_.at(index())
		                 : mesh.primal_edge_next_.at(index());
	}
	Edge origin_prev(const Mesh&amp; mesh)const {
		return rot().origin_next(mesh).rot();
	}
	Edge dest_next(const Mesh&amp; mesh)const {
		return sym().origin_next(mesh).sym();
	}
	Edge dest_prev(const Mesh&amp; mesh)const {
		return inv_rot().origin_next(mesh).inv_rot();
	}
	Edge left_next(const Mesh&amp; mesh)const {
		return inv_rot().origin_next(mesh).rot();
	}
	Edge left_prev(const Mesh&amp; mesh)const {
		return origin_next(mesh).sym();
	}
	Edge right_next(const Mesh&amp; mesh)const {
		return rot().origin_next(mesh).inv_rot();
	}
	Edge right_prev(const Mesh&amp; mesh)const {
		return sym().origin_next(mesh);
	}
};
</code></pre>

<figure class="captioned_image fill_black float_right">
	<a class="open_img" href="/assets/images/quad_edge/origin_prev.png" target="_blank" rel="noopener noreferrer" onclick="show_image_overlay(event, this)">
		<img style="float:none; max-height:20em" src="/assets/images/quad_edge/origin_prev.png" alt="" />
	</a>
  <figcaption></figcaption>
</figure>

<p>One example for the methods above, that shows how <code>origin_prev()</code> can be implemented in terms of <code>origin_next()</code>.</p>

<p>The key here is that we first rotate the edge, to get the dual edge that points from the right to the left face. Just like with primal edges we can use <code>origin_next()</code> to get the next (counter-clockwise) edge around the origin, but for dual edges that origin is a face instead of a vertex. So when we rotate our dual edge, we get the dual edge that point “through” the next edge of the right face or in other words <code>origin_prev()</code> of our original mesh. And to get this primal edge, we then just need to rotate the dual edge again.</p>

<p><br style="clear:both" /></p>

<h3 id="higher-level-abstractions">Higher level abstractions</h3>

<p>Based on the relativly simple operations, we have seen so far, we can now construct higher level abstraction to navigate the topology. One operation we need relativly often is iterating over every neighbor of a given vertex<sup class="footnote" onclick="showFootnote(this)" title="i.e. all vertices that share an edge with the given vertex">[11]</sup>, which can be implemented as:</p>

<pre><code class="language-cpp">// get any edge that points away from the vertex
auto edge = vertex.edge(mesh);
auto e    = edge;
do {
	// get the destination vertex of the current edge
	auto v = e.dest(mesh);
	// use v
	
	// get the next (CCW) edge
	e = e.origin_next(mesh);
	
	// if the next edge is the one we started with,
	//   we have visited all edges and can stop
} while(e!=edge);
</code></pre>

<p>Precisely because this is a common operation, the actual API provides iterators and methods that simplify the above code to:</p>
<pre><code class="language-cpp">for(auto v : mesh.neighbors(vertex)) {
	// use v
}
</code></pre>

<p>One part of the API we’ve ignored so far is how we construct a mesh to begin with. And for some of the algorithms we will also need to be able to modify an existing mesh. The operations we will need for this are:</p>
<ul>
  <li>Create a new triangle face that connects three vertices</li>
  <li>Filp the central edge of two adjaicent faces, i.e. remove the shared edge and replace it with a new edge between the two previously unconnected vertices</li>
  <li>Split an edge into two edges, inserting a new vertex and new faces between them</li>
  <li>Collapse an edge, i.e. merge two vertices and remove the edges and faces between them</li>
</ul>

<p>But because these operations are bit more complex and this post is already far longer than I originaly planed, we will look at that in a future post.</p>

<h2 id="positions-elevations-and-other-additional-information">Positions, elevations and other additional information</h2>

<p>However, there is one part we have to still talk about. Everything we have talked about so far is purely concerned with the topology – which vertices/faces are connected to each other – and doesn’t care about how it is actually layed out in space. That is, if it can be layed out without intersecting itself, it doesn’t matter if our basic shape is a sphere, cube, plane or tesseract<sup class="footnote" onclick="showFootnote(this)" title="which is quite neat, I think, and allows us a lot of flexiblity in the future.">[12]</sup>.</p>

<p>But even if our data structure doesn’t care about the positions in space, we still do for many applications and need a way to store them. We’ve already touched on the fact that we can use the IDs of our vertices/faces/edges to link them to additional information like elevation or temperature and we will handle their positions in exactly the same way. Because our elements are layed out in a continous vector in memory<sup class="footnote" onclick="showFootnote(this)" title="While there might be some holes in our data, which we will discus in the next post, there should never be more than a small percentage and we can ignore that for now.">[13]</sup> and our IDs are based on their position, we can also just use a vector for our addition data and use the IDs to index into them.</p>

<p>While that will work there is a bit more complexity to handle changes when we modify the mesh later. And a bit of validation and type-safety would also be a welcome addition. To achieve that we will create a new <code>Layer</code> type that stores information linked to a given part of our mesh, that looks like this<sup class="footnote" onclick="showFootnote(this)" title="This is again a somewhat simplified example that ignors many aspects such as constexpr, [[nodiscard]], data-members and constructors. ">[14]</sup>:</p>
<pre><code class="language-cpp">enum class Layer_type {
	vertex, face, edge_primal, edge_primal_directed, edge_dual, edge_dual_directed
};
	
template &lt;typename T, Layer_type Element&gt;
class Layer {
  public:
	// access the data for a specific element
	// parameter type is Vertex, Face or Edge depending on the Layer_type
	T&amp;       operator[](type&lt;Element&gt;);
	const T&amp; operator[](type&lt;Element&gt;)const;
	
	size_t size() const;
	bool   empty() const;
	
	// begin() and end() so the type can be used in range-for loops
	T*       begin();
	const T* begin()const;
	T*       end();
	const T* end()const;

  private:
	// ...
};
</code></pre>

<p>Because <code>Layer</code> is a class template it can be used to store all kinds of different data types<sup class="footnote" onclick="showFootnote(this)" title="Also, because of other parts of the system that is currently limited to: bool, int8, int32, float and a 2D and 3D float-Vector ">[15]</sup> and can reference vertices, faces and all types of edges. Not all data is directly related to parts of the mesh or might be so sparse that a continous storage doesn’t make sense. For these cases there will also be unstructed data layers, that model a simple key-value store, which me might discuss later.</p>

<p>One thing that might be a bit supprising at first is the number of possible types of edges in <code>Layer_type</code>. In addition to the distinction between primal and dual edges, we also differenciate between directed and undirected edges here. While the edges in our mesh are always directed, many information we might want to store about them will be identical for both directions. For example when we model plate tectonics and store the type of interaction between all vertices, we would choose <code>edge_primal</code> instead of <code>edge_primal_directed</code> and only require half the memory to store our data.</p>

<h2 id="world-class">World class</h2>

<p>As already noted the Layers might need to be update whenever the mesh is modified, which means both are heavily intertwined. So it isn’t realy feasible to construct them intependently from each other. Hence we will encapsualte both in a <code>World</code> type that manages both the <code>Mesh</code> and any created <code>Layer</code>:</p>

<pre><code class="language-cpp">class World {
  public:
	const Mesh&amp; mesh() const;

	const Dict* layer(std::string_view id) const;

	template &lt;typename LayerInfo&gt;
	const typename LayerInfo::layer_t* layer(const LayerInfo&amp; info) const;

  private:
	// ...
};
</code></pre>

<p>Besides the <code>mesh()</code> getter the class also contains to getters for layers, one for simple unstrctured layers – that just have a name – and one for our more complex mesh-based layers.<sup class="footnote" onclick="showFootnote(this)" title="Both of the layer-getters return a pointer, because the layer might not exist, yet. But there is always a mesh, even though it might still be empty.">[16]</sup> The latter is again a template, which hopefully is not thatsuprising because our <code>Layer</code> was also a template. But the parameter of the method probably warrants some further explaination. Every layer has a name with which its referenced in the procedural generation code, but it also has a couple of additional metadata linked to it:</p>
<ol>
  <li>The type of the data that it stores (<code>T</code> template parameter in <code>Layer</code>)</li>
  <li>What its data is linked to in the mesh (<code>Layer_type</code>)</li>
  <li>The initial value of its data (used both when its first created and when e.g. a new vertex is added to the mesh)</li>
  <li>The range of valid values (only positive numbers, only numbers between 0 and 10, …)</li>
  <li>Whether its data should be automatically validated against this range, to detect runtime errors</li>
  <li>How the data should react to changes of the mesh (e.g. when an edge is split, should the value for the new vertex be interpolated between the original origin and destination, reset to the initial value, use the min/max of the values, …?)</li>
</ol>

<p>Because of that we also introduce a new type <code>Layer_info</code> to describe what a layer looks like and how it should behave, which can be constructed and then used to retrieve a concrete layer from the <code>World</code>:</p>

<pre><code class="language-cpp">constexpr auto distance_layer = Layer_info&lt;float, Layer_type::edge_primal&gt;("plate_distance")
                                .initial(-1.f);

if(auto dist = world.layer(distance_layer)) {
	// once we have the layer, we can access its data with the operator[] defined in the Layer class 
	std::cout &lt;&lt; (*dist)[Edge(false, 42)] &lt;&lt; '\n';
}
</code></pre>

<p>TODO: copy-on-write for easy undo/redo and parallel processing</p>

<pre><code class="language-cpp">constexpr auto position_layer = Layer_info&lt;Vec3, Layer_type::vertex&gt;("position");
		
auto [positions] = world.lock_layer(position_layer);

positions[Vertex(42)] = Vec3{10.f, -2.f, 3.f};
</code></pre>

:ET